//Урок 1. Побитовые операции и битовые поля
//Задание 4. Шифр Цезаря
//На стандартном потоке ввода задается целое неотрицательное число N и
//последовательность допустимых символов в кодировке ASCII,
//оканчивающаяся точкой. Допустимые символы – латинские буквы 'a' ... 'z', 'A' ...
//'Z' и пробел. Требуется закодировать латинские буквы ('a' ... 'z', 'A' ... 'Z')
//шифром Цезаря, пробелы вывести без изменения. Число N задает сдвиг в
//шифре. Шифр Цезаря заключается в следующем преобразовании. Пусть буквы
//алфавита пронумерованы от 0 до K - 1, где K - число символов в алфавите.
//Тогда символ с номером n кодируется символом с номером p = (n + N) mod K
//(mod - операция взятия остатка). На стандартном потоке вывода напечатать
//зашифрованное сообщение, оканчивающееся точкой. Преобразование
//требуется выполнять независимо для заглавных и строчных латинских букв.
//Указание: использовать массивы запрещается
//Данные на входе: Натуральное число N (N > 0), после которого следует
//сообщение.
//Данные на выходе: Зашифрованное сообщение.
//Данные на входе: 1 Aa.
//Данные на выходе: Bb.

#include <stdio.h>
#include <stdint.h>
char cshifer(char, unsigned int);
int main()
{
unsigned int n;
char ch;
printf("Input n and fraze\n");
scanf("%u",  &n);
while('.' != (ch=getchar()))
{
putchar (cshifer(ch, n));
}
putchar('.');
putchar('\n');
return 0;
}
char cshifer(char ch, unsigned int n)
{
char base;
const char range='z'-'a'+1;
char shift =n% range;
switch (ch){
	case 'a' ... 'z':
	base='a';
	break;
	case 'A' ... 'Z':
	base='A';
	break;
	default:
	return ch;
	break;
			}
	return base+((ch+shift-base) % range);
}
